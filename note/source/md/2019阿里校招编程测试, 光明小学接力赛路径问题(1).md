[//]: # (20180820)
[//]: # (2019阿里校招编程测试, 光明小学接力赛路径问题。)
# 2019阿里校招编程测试, 光明小学接力赛路径问题(1)

### 题目

光明小学的小朋友们要举行一年一度的接力跑大赛了，但是小朋友们却遇到了一个难题：设计接力跑大赛的线路，你能帮助他们完成这项工作么？

光明小学可以抽象成一张有N个节点的图，每两点间都有一条道路相连。光明小学的每个班都有M个学生，所以你要为他们设计出一条恰好经过M条边的路径。

光明小学的小朋友们希望全盘考虑所有的因素，所以你需要把任意两点间经过M条边的最短路径的距离输出出来以供参考。

你需要设计这样一个函数：
``` cpp
res[][] Solve( N, M, map[][]);
```
**注意：map必然是N * N的二维数组，且map[i][j] == map[j][i]，map[i][i] == 0，-1e8 <= map[i][j] <= 1e8。（道路全部是无向边，无自环）2 <= N <= 100, 2 <= M <= 1e6。要求时间复杂度控制在O(N^3*log(M))。**

map数组表示了一张稠密图，其中任意两个不同节点i,j间都有一条边，边的长度为map[i][j]。N表示其中的节点数。

你要返回的数组也必然是一个N * N的二维数组，表示从i出发走到j，经过M条边的最短路径。
你的路径中应考虑包含重复边的情况。

样例:
``` cpp
N = 2;
M = 3;
map = {
{0, 2, 3},
{2, 0, 1},
{3, 1, 0}};
```
输出结果:
``` cpp
result = {
{4, 4, 3},
{4, 2, 5},
{3, 5, 2}};
```
样例解释:
```
1->1有两种方法: 1->2->1(长度为2+2=4), 1->3->1（长度为3+3=6）
2->2有两种方法: 2->1->2(长度为2+2=4), 2->3->2（长度为1+1=2）
1->1有两种方法: 3->1->3(长度为3+3=6), 3->2->3（长度为1+1=2）
1->2只有一种方法: 1->3->2(长度为3+1=4)
1->3只有一种方法: 1->2->3(长度为2+1=4)
2->3只有一种方法: 2->1->3(长度为2+3=5)
根据对称性可以得到其它部分的答案。
```

### 思路
#### 先考虑M=1的情况:
设起点为i, 终点为j

约束: 起点和终点不能相同

则距离distance(i,j)为`map[i][j]`(i!=j)。

#### 考虑M增加到2:
设起点为i, 终点为j, 中间经过点为k

约束: 起点和中间点, 中间点和终点不能相同

则对于一个确定的中间点k, 距离distance(i,j,k)为`map[i][k]+map[k][j]`(i!=k且k!=j)

根据题目要求, 两点间距离为所有k中距离最短的路程: distance(i,j) = min(distance(i,j,k)) for every k

#### 考虑M增加到m:
设起点为i, 终点为j, 终点前一个点为k, i到k走了m-1步形成的距离矩阵为D

约束: 终点和终点前一个点不能相同

则对于一个确定的终点前一个点k, 距离distance(i,j,k)为`D[i,k]+map[k,j]`(k!=j)

根据题目要求, 起点到终点距离为所有k中距离最短的路程: distance(i,j) = min(distance(i,j,k)) for every k

#### 时间复杂度
外层M次循环, 内层嵌套两层N次的循环外加一个长度为N的遍历, 故时间复杂度为O(M*N^3), 未能达到要求。

思路应该是以增加空间使用量为代价来减少外层循环次数。改进后的程序见下篇。

### 程序
给出的语言中Python版本只有2.7:
``` python
import copy

N = 3
M = 2
g = [
[0, 2, 3],
[2, 0, 1],
[3, 1, 0]]

res = copy.deepcopy(g)
tmp = copy.deepcopy(g)

for l in range(M-1):
    for i in range(N):
        for j in range(N):
            res[i][j] = min([tmp[i][k] + g[k][j] for k in range(N) if (l or k!=i) and k!=j])
    tmp = copy.deepcopy(res)

print res
```
### 注意
#### copy.deepcopy
python中当列表为嵌套列表时, 直接赋值或切片赋值都会导致两个变量指向一个对象:
``` python
L1 = [[1,2,3],[4,5,6]]
L2 = L1
L3 = L1[:]
L1[0][0] = 250
print(L2,L3)
# -> ([[250, 2, 3], [4, 5, 6]], [[250, 2, 3], [4, 5, 6]])
```
#### M=2和M=3约束不同
M=2时第一步中起点和终点不能相同, 而M=3时前两步过程中起点和终点可以相同。

### 思考
题目中map矩阵中对角线为0, 表示自己与自己距离为0, 在题目实现时其实可以将对角线的0改成无穷大来对起点终点相同进行惩罚从而简化约束条件。
