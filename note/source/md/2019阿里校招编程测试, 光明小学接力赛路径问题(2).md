[//]: # (20180910)
[//]: # (2019阿里校招编程测试, 光明小学接力赛路径问题。)
# 2019阿里校招编程测试, 光明小学接力赛路径问题(2)

### 题目

光明小学的小朋友们要举行一年一度的接力跑大赛了，但是小朋友们却遇到了一个难题：设计接力跑大赛的线路，你能帮助他们完成这项工作么？

光明小学可以抽象成一张有N个节点的图，每两点间都有一条道路相连。光明小学的每个班都有M个学生，所以你要为他们设计出一条恰好经过M条边的路径。

光明小学的小朋友们希望全盘考虑所有的因素，所以你需要把任意两点间经过M条边的最短路径的距离输出出来以供参考。

你需要设计这样一个函数：
``` cpp
res[][] Solve( N, M, map[][]);
```
**注意：map必然是N * N的二维数组，且map[i][j] == map[j][i]，map[i][i] == 0，-1e8 <= map[i][j] <= 1e8。（道路全部是无向边，无自环）2 <= N <= 100, 2 <= M <= 1e6。要求时间复杂度控制在O(N^3*log(M))。**

map数组表示了一张稠密图，其中任意两个不同节点i,j间都有一条边，边的长度为map[i][j]。N表示其中的节点数。

你要返回的数组也必然是一个N * N的二维数组，表示从i出发走到j，经过M条边的最短路径。
你的路径中应考虑包含重复边的情况。

样例:
``` cpp
N = 2;
M = 3;
map = {
{0, 2, 3},
{2, 0, 1},
{3, 1, 0}};
```
输出结果:
``` cpp
result = {
{4, 4, 3},
{4, 2, 5},
{3, 5, 2}};
```
样例解释:
```
1->1有两种方法: 1->2->1(长度为2+2=4), 1->3->1（长度为3+3=6）
2->2有两种方法: 2->1->2(长度为2+2=4), 2->3->2（长度为1+1=2）
1->1有两种方法: 3->1->3(长度为3+3=6), 3->2->3（长度为1+1=2）
1->2只有一种方法: 1->3->2(长度为3+1=4)
1->3只有一种方法: 1->2->3(长度为2+1=4)
2->3只有一种方法: 2->1->3(长度为2+3=5)
根据对称性可以得到其它部分的答案。
```

### 思路
#### 规范化map
规范化map主要的好处就是可以将上次得到的约束普遍化。在原始的map里面对起点和终点相同的情况加以惩罚因子, 具体操作就是将起点终点相同的距离设为无穷大, 而不是原来的0。

#### 构建函数
程序中需要两个函数:
``` python
def graphForM(D, N):
    ...

def combineGraph(g1, g2):
    ...
```

其中graphForM的作用是获得M个人时的结果, combineGraph在已知n1个人的结果(g1)和n2个人的结果(g2)来得到n1+n2个人的结果的。

#### 时间复杂度
外层log(M)次循环, 内层嵌套两层N次的循环外加一个长度为n的遍历, 故时间复杂度为O(log(M)*N^3), 符合题目要求。

### 程序

``` python
def combineGraph(g1, g2):
    h = len(g1)
    res = []
    for i in range(h):
        res.append([])
        for j in range(h):
            res[i].append(min([g1[i][k]+g2[k][j] for k in range(h)]))
    return res

def graphForM(D, N): 
    if N in D:
        return D[N]
    if N % 2:
        tmpg = combineGraph(graphForM(D, N//2), graphForM(D, N//2))
        D[N] = combineGraph(tmpg, D[1])
        return D[N]
    else:
        return combineGraph(graphForM(D, N//2), graphForM(D, N//2))

inf = 10000
N = 3
M = 2
_map = [
[0,2,3],
[2,0,1],
[3,1,0]]

g = []
for item in _map:
    tmp = []
    for i in item:
        if i:
            tmp.append(i)
        else:
            tmp.append(inf)
    g.append(tmp)

D = {}
D[1] = g 
print graphForM(D, M)
```

